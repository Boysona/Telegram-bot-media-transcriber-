import os
import re
import uuid
import shutil
import logging
import requests
import telebot
import json
from flask import Flask, request, abort
from faster_whisper import WhisperModel
from datetime import datetime
import yt_dlp
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton

# Configure logger
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Bot token and required channel
TOKEN = "7770743573:AAG1ewm-hyqVIYsFgJGzVz7oOzFnRTvP2TY"
REQUIRED_CHANNEL = "@transcriberbo"

bot = telebot.TeleBot(TOKEN, threaded=True)
app = Flask(__name__)

# Admin ID
ADMIN_ID = 5978150981

# Download directory
DOWNLOAD_DIR = "downloads"
os.makedirs(DOWNLOAD_DIR, exist_ok=True)

# Whisper model for transcription
model = WhisperModel(model_size_or_path="tiny", device="cpu", compute_type="int8")

# User tracking file
users_file = 'users.json'
user_data = {}
if os.path.exists(users_file):
    with open(users_file, 'r') as f:
        try:
            user_data = json.load(f)
        except json.JSONDecodeError:
            user_data = {}

# User-specific language settings
user_language_settings_file = 'user_language_settings.json'
user_language_settings = {}
if os.path.exists(user_language_settings_file):
    with open(user_language_settings_file, 'r') as f:
        try:
            user_language_settings = json.load(f)
        except json.JSONDecodeError:
            user_language_settings = {}

def save_user_data():
    with open(users_file, 'w') as f:
        json.dump(user_data, f, indent=4)

def save_user_language_settings():
    with open(user_language_settings_file, 'w') as f:
        json.dump(user_language_settings, f, indent=4)

# In-memory chat history and transcription store
user_memory = {}
user_transcriptions = {}  # Format: {user_id: {message_id: "transcription_text"}}

# Statistics counters
total_files_processed = 0
total_audio_files = 0
total_voice_clips = 0
total_videos = 0
total_tiktok_downloads = 0
total_processing_time = 0  # in seconds
processing_start_time = None

GEMINI_API_KEY = "AIzaSyAto78yGVZobxOwPXnl8wCE9ZW8Do2R8HA"

def ask_gemini(user_id, user_message):
    user_memory.setdefault(user_id, []).append({"role": "user", "text": user_message})
    history = user_memory[user_id][-10:]
    parts = [{"text": msg["text"]} for msg in history]
    url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={GEMINI_API_KEY}"
    resp = requests.post(url, headers={'Content-Type': 'application/json'}, json={"contents": [{"parts": parts}]})
    result = resp.json()
    if "candidates" in result:
        reply = result['candidates'][0]['content']['parts'][0]['text']
        user_memory[user_id].append({"role": "model", "text": reply})
        return reply
    return "Error: " + json.dumps(result)

FILE_SIZE_LIMIT = 20 * 1024 * 1024  # 20MB
admin_state = {}

def set_bot_info():
    commands = [
        telebot.types.BotCommand("start", "Restart the bot"),
        telebot.types.BotCommand("status", "View bot statistics"),
        telebot.types.BotCommand("help", "View usage instructions"),
        telebot.types.BotCommand("language", "Change preferred language"),
        telebot.types.BotCommand("privacy", "View privacy notice"),
    ]
    bot.set_my_commands(commands)

    bot.set_my_short_description("Upload media or links and get quick transcriptions!")
    bot.set_my_description(
        "This bot transcribes, summarizes, and translates voice messages, audio files, videos, TikTok videos, and YouTube videosâ€”all for free!"
    )

def check_subscription(user_id):
    try:
        member = bot.get_chat_member(REQUIRED_CHANNEL, user_id)
        return member.status in ['member', 'administrator', 'creator']
    except telebot.apihelper.ApiTelegramException:
        return False

def send_subscription_message(chat_id):
    markup = telebot.types.InlineKeyboardMarkup()
    markup.add(
        telebot.types.InlineKeyboardButton("Join the channel", url=f"https://t.me/{REQUIRED_CHANNEL[1:]}")
    )
    bot.send_message(
        chat_id,
        "You must join @transcriberbo to use this bot. Please join and try again.",
        reply_markup=markup
    )

def update_user_activity(user_id):
    user_data[str(user_id)] = datetime.now().isoformat()
    save_user_data()

# Regex for TikTok and YouTube (including shorts and youtu.be)
TIKTOK_REGEX = re.compile(r'(https?://)?(www\.)?(vm\.)?tiktok\.com/[^\s]+')
YOUTUBE_REGEX = re.compile(r'(https?://)?(www\.)?(youtube\.com/(watch\?v=|shorts/)|youtu\.be/)[^\s]+')

@bot.message_handler(commands=['start'])
def start_handler(message):
    user_id = str(message.from_user.id)
    update_user_activity(message.from_user.id)
    if user_id not in user_data:
        user_data[user_id] = datetime.now().isoformat()
        save_user_data()
    if not check_subscription(message.from_user.id):
        return send_subscription_message(message.chat.id)

    if message.from_user.id == ADMIN_ID:
        keyboard = telebot.types.ReplyKeyboardMarkup(resize_keyboard=True)
        keyboard.add("Send Broadcast", "Total Users", "/status")
        bot.send_message(message.chat.id, "Admin panel activated.", reply_markup=keyboard)
    else:
        bot.send_message(
            message.chat.id,
            "Welcome! Send me any of the following:\n"
            "â€¢ Voice message\n"
            "â€¢ Audio file\n"
            "â€¢ Video file\n"
            "â€¢ TikTok video link\n"
            "â€¢ YouTube video or shorts link\n"
            "and I will transcribe them for free.",
            parse_mode="Markdown"
        )

@bot.message_handler(commands=['help'])
def help_handler(message):
    help_text = (
        "â„¹ï¸ **How to use this bot:**\n\n"
        "1. **Join the Channel:** Make sure you are a member of @transcriberbo.\n"
        "2. **Send Media or Link:** Send a voice message, audio file, video file, TikTok URL, or YouTube URL.\n"
        "3. **Get Transcription:** The bot will transcribe your input and send back the text. Long transcriptions are delivered as a text file.\n"
        "4. **Optional Actions:** After receiving the transcription, you can choose to translate or summarize it.\n\n"
        "**Available Commands:**\n"
        "/start â€” Restart the bot\n"
        "/status â€” View bot statistics\n"
        "/help â€” Show this help message\n"
        "/language â€” Change your preferred language for translation/summarization\n"
        "/privacy â€” View privacy notice\n"
    )
    bot.send_message(message.chat.id, help_text, parse_mode="Markdown")

@bot.message_handler(commands=['privacy'])
def privacy_notice_handler(message):
    privacy_text = (
        "**Privacy Notice**\n\n"
        "**Data We Process:**\n"
        "- **Media Files:** Any media or links you send are processed temporarily for transcription and deleted immediately after.\n"
        "- **Transcriptions:** Text transcriptions are stored in memory only until you choose to translate or summarize. We do not save them longâ€‘term.\n"
        "- **User IDs:** We store your Telegram user ID to manage preferences and show usage statistics. We do not link it to any personal data.\n"
        "- **Language Preferences:** We save your chosen language for translations and summaries to remember your preference.\n\n"
        "**How We Use Your Data:**\n"
        "- To provide transcription, translation, and summarization services.\n"
        "- To improve bot performance through aggregated usage statistics.\n"
        "- To remember your language preference.\n\n"
        "**Data Sharing:**\n"
        "- We do not share your media, transcriptions, or personal data with third parties.\n"
        "- Transcription and translation are performed using Whisper and Gemini APIs, and we do not store your inputs permanently.\n\n"
        "**Data Retention:**\n"
        "- Media files are deleted immediately after transcription.\n"
        "- Transcriptions are held in memory temporarily.\n"
        "- User IDs and language preferences are retained until you stop using the bot or request deletion.\n\n"
        "By using this bot, you agree to this Privacy Notice. If you have questions, please contact the bot administrator."
    )
    bot.send_message(message.chat.id, privacy_text, parse_mode="Markdown")

@bot.message_handler(commands=['status'])
def status_handler(message):
    update_user_activity(message.from_user.id)

    today = datetime.now().date()
    active_today = sum(
        1 for ts in user_data.values()
        if datetime.fromisoformat(ts).date() == today
    )

    total_seconds = int(total_processing_time)
    hours = total_seconds // 3600
    minutes = (total_seconds % 3600) // 60
    seconds = total_seconds % 60

    text = (
        "ðŸ“Š **Bot Statistics**\n\n"
        f"â€¢ Total Users Active Today: {active_today}\n\n"
        f"â€¢ Total Files Processed: {total_files_processed}\n"
        f"â€¢ Audio Files: {total_audio_files}\n"
        f"â€¢ Voice Clips: {total_voice_clips}\n"
        f"â€¢ Videos: {total_videos}\n"
        f"â€¢ TikTok Downloads: {total_tiktok_downloads}\n\n"
        f"â± Total Processing Time: {hours}h {minutes}m {seconds}s"
    )
    bot.send_message(message.chat.id, text, parse_mode="Markdown")

@bot.message_handler(func=lambda m: m.text == "Total Users" and m.from_user.id == ADMIN_ID)
def total_users(message):
    bot.send_message(message.chat.id, f"Total registered users: {len(user_data)}")

@bot.message_handler(func=lambda m: m.text == "Send Broadcast" and m.from_user.id == ADMIN_ID)
def send_broadcast(message):
    admin_state[message.from_user.id] = 'awaiting_broadcast'
    bot.send_message(message.chat.id, "Please send the broadcast message now:")

@bot.message_handler(
    func=lambda m: m.from_user.id == ADMIN_ID and admin_state.get(m.from_user.id) == 'awaiting_broadcast',
    content_types=['text', 'photo', 'video', 'audio', 'document']
)
def broadcast_message(message):
    admin_state[message.from_user.id] = None
    success = fail = 0
    for uid in user_data:
        try:
            bot.copy_message(uid, message.chat.id, message.message_id)
            success += 1
        except telebot.apihelper.ApiTelegramException:
            fail += 1
    bot.send_message(
        message.chat.id,
        f"Broadcast complete.\nSuccessful: {success}\nFailed: {fail}"
    )

# TikTok link detection
@bot.message_handler(func=lambda m: m.text and TIKTOK_REGEX.search(m.text))
def tiktok_link_handler(message):
    url = TIKTOK_REGEX.search(message.text).group(0)
    markup = InlineKeyboardMarkup()
    markup.add(
        InlineKeyboardButton("Download TikTok", callback_data=f"download|{url}"),
        InlineKeyboardButton("Transcribe TikTok", callback_data=f"transcribe_tiktok|{url}|{message.message_id}")
    )
    bot.send_message(message.chat.id, "TikTok link detected. Choose an action:", reply_markup=markup)

@bot.callback_query_handler(func=lambda c: c.data.startswith("download|"))
def callback_download_tiktok(call):
    global total_tiktok_downloads
    _, url = call.data.split("|", 1)

    bot.send_chat_action(call.message.chat.id, 'upload_video')

    try:
        ydl_opts = {
            'outtmpl': os.path.join(DOWNLOAD_DIR, '%(id)s.%(ext)s'),
            'format': 'mp4',
        }
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=True)
            path = ydl.prepare_filename(info)
            caption = info.get('description', 'No description.')

        with open(path, 'rb') as video:
            bot.send_video(call.message.chat.id, video)
        bot.send_message(call.message.chat.id, f"{caption}")
        total_tiktok_downloads += 1
    except Exception as e:
        logging.error(f"TikTok download error: {e}")
        bot.send_message(call.message.chat.id, "Failed to download the TikTok video.")
    finally:
        if 'path' in locals() and os.path.exists(path):
            os.remove(path)

@bot.callback_query_handler(func=lambda c: c.data.startswith("transcribe_tiktok|"))
def callback_transcribe_tiktok(call):
    _, url, message_id_str = call.data.split("|", 2)
    message_id = int(message_id_str)
    bot.send_chat_action(call.message.chat.id, 'typing')
    try:
        ydl_opts = {
            'outtmpl': os.path.join(DOWNLOAD_DIR, '%(id)s.%(ext)s'),
            'format': 'mp4',
        }
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=True)
            path = ydl.prepare_filename(info)

        global processing_start_time
        processing_start_time = datetime.now()

        transcription = transcribe(path) or ""
        uid = str(call.from_user.id)
        user_transcriptions.setdefault(uid, {})[message_id] = transcription

        processing_time = (datetime.now() - processing_start_time).total_seconds()
        global total_processing_time
        total_processing_time += processing_time

        buttons = InlineKeyboardMarkup()
        buttons.add(
            InlineKeyboardButton("Translate", callback_data=f"btn_translate|{message_id}"),
            InlineKeyboardButton("Summarize", callback_data=f"btn_summarize|{message_id}")
        )

        if len(transcription) > 4000:
            fn = 'tiktok_transcription.txt'
            with open(fn, 'w', encoding='utf-8') as f:
                f.write(transcription)
            bot.send_chat_action(call.message.chat.id, 'upload_document')
            with open(fn, 'rb') as doc:
                bot.send_document(
                    call.message.chat.id,
                    doc,
                    reply_markup=buttons,
                    caption="Here is your TikTok transcription. Use the buttons below to translate or summarize."
                )
            os.remove(fn)
        else:
            bot.send_chat_action(call.message.chat.id, 'typing')
            bot.send_message(
                call.message.chat.id,
                transcription,
                reply_markup=buttons
            )
    except Exception as e:
        logging.error(f"TikTok transcribe error: {e}")
        bot.send_message(call.message.chat.id, "Failed to transcribe the TikTok video.")
    finally:
        if 'path' in locals() and os.path.exists(path):
            os.remove(path)

# YouTube link detection (including shorts and youtu.be)
@bot.message_handler(func=lambda m: m.text and YOUTUBE_REGEX.search(m.text))
def youtube_link_handler(message):
    url = YOUTUBE_REGEX.search(message.text).group(0)
    markup = InlineKeyboardMarkup()
    markup.add(
        InlineKeyboardButton("Transcribe YouTube", callback_data=f"transcribe_youtube|{url}|{message.message_id}")
    )
    bot.send_message(message.chat.id, "YouTube link detected. Choose an action:", reply_markup=markup)

@bot.callback_query_handler(func=lambda c: c.data.startswith("transcribe_youtube|"))
def callback_transcribe_youtube(call):
    _, url, message_id_str = call.data.split("|", 2)
    message_id = int(message_id_str)
    bot.send_chat_action(call.message.chat.id, 'typing')
    try:
        ydl_opts = {
            'outtmpl': os.path.join(DOWNLOAD_DIR, '%(id)s.%(ext)s'),
            'format': 'bestaudio/best',
        }
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=True)
            path = ydl.prepare_filename(info)

        global processing_start_time
        processing_start_time = datetime.now()
        transcription = transcribe(path) or ""
        uid = str(call.from_user.id)
        user_transcriptions.setdefault(uid, {})[message_id] = transcription

        processing_time = (datetime.now() - processing_start_time).total_seconds()
        global total_processing_time
        total_processing_time += processing_time

        buttons = InlineKeyboardMarkup()
        buttons.add(
            InlineKeyboardButton("Translate", callback_data=f"btn_translate|{message_id}"),
            InlineKeyboardButton("Summarize", callback_data=f"btn_summarize|{message_id}")
        )

        if len(transcription) > 4000:
            fn = 'youtube_transcription.txt'
            with open(fn, 'w', encoding='utf-8') as f:
                f.write(transcription)
            bot.send_chat_action(call.message.chat.id, 'upload_document')
            with open(fn, 'rb') as doc:
                bot.send_document(
                    call.message.chat.id,
                    doc,
                    reply_markup=buttons,
                    caption="Here is your YouTube transcription. Use the buttons below to translate or summarize."
                )
            os.remove(fn)
        else:
            bot.send_chat_action(call.message.chat.id, 'typing')
            bot.send_message(
                call.message.chat.id,
                transcription,
                reply_markup=buttons
            )
    except Exception as e:
        logging.error(f"YouTube transcribe error: {e}")
        bot.send_message(call.message.chat.id, "Failed to transcribe the YouTube video.")
    finally:
        if 'path' in locals() and os.path.exists(path):
            os.remove(path)

@bot.message_handler(content_types=['voice', 'audio', 'video', 'video_note'])
def handle_file(message):
    global total_files_processed, total_audio_files, total_voice_clips, total_videos, total_processing_time
    update_user_activity(message.from_user.id)
    if not check_subscription(message.from_user.id):
        return send_subscription_message(message.chat.id)

    file_obj = message.voice or message.audio or message.video or message.video_note
    if file_obj.file_size > FILE_SIZE_LIMIT:
        return bot.send_message(message.chat.id, "File is too large (max 20MB). Please send a smaller file.")

    info = bot.get_file(file_obj.file_id)
    local_path = os.path.join(DOWNLOAD_DIR, f"{uuid.uuid4()}.ogg")
    bot.send_chat_action(message.chat.id, 'typing')

    try:
        data = bot.download_file(info.file_path)
        with open(local_path, 'wb') as f:
            f.write(data)

        bot.send_chat_action(message.chat.id, 'typing')
        global processing_start_time
        processing_start_time = datetime.now()

        transcription = transcribe(local_path) or ""
        uid = str(message.from_user.id)
        user_transcriptions.setdefault(uid, {})[message.message_id] = transcription

        total_files_processed += 1
        if message.voice:
            total_voice_clips += 1
        elif message.audio:
            total_audio_files += 1
        elif message.video or message.video_note:
            total_videos += 1

        processing_time = (datetime.now() - processing_start_time).total_seconds()
        total_processing_time += processing_time

        buttons = InlineKeyboardMarkup()
        buttons.add(
            InlineKeyboardButton("Translate", callback_data=f"btn_translate|{message.message_id}"),
            InlineKeyboardButton("Summarize", callback_data=f"btn_summarize|{message.message_id}")
        )

        if len(transcription) > 4000:
            fn = 'transcription.txt'
            with open(fn, 'w', encoding='utf-8') as f:
                f.write(transcription)
            bot.send_chat_action(message.chat.id, 'upload_document')
            with open(fn, 'rb') as doc:
                bot.send_document(
                    message.chat.id,
                    doc,
                    reply_to_message_id=message.message_id,
                    reply_markup=buttons,
                    caption="Here is your transcription. Use the buttons below to translate or summarize."
                )
            os.remove(fn)
        else:
            bot.reply_to(
                message,
                transcription,
                reply_markup=buttons
            )
    except Exception as e:
        logging.error(f"Error processing file: {e}")
        bot.send_message(message.chat.id, "An error occurred while transcribing your file.")
    finally:
        if os.path.exists(local_path):
            os.remove(local_path)

# --- Language Selection and Saving ---
LANGUAGES = [
    {"name": "English", "flag": "ðŸ‡¬ðŸ‡§"},
    {"name": "Chinese", "flag": "ðŸ‡¨ðŸ‡³"},
    {"name": "Spanish", "flag": "ðŸ‡ªðŸ‡¸"},
    {"name": "Hindi", "flag": "ðŸ‡®ðŸ‡³"},
    {"name": "Arabic", "flag": "ðŸ‡¸ðŸ‡¦"},
    {"name": "French", "flag": "ðŸ‡«ðŸ‡·"},
    {"name": "Bengali", "flag": "ðŸ‡§ðŸ‡©"},
    {"name": "Russian", "flag": "ðŸ‡·ðŸ‡º"},
    {"name": "Portuguese", "flag": "ðŸ‡µðŸ‡¹"},
    {"name": "Urdu", "flag": "ðŸ‡µðŸ‡°"},
    {"name": "German", "flag": "ðŸ‡©ðŸ‡ª"},
    {"name": "Japanese", "flag": "ðŸ‡¯ðŸ‡µ"},
    {"name": "Korean", "flag": "ðŸ‡°ðŸ‡·"},
    {"name": "Vietnamese", "flag": "ðŸ‡»ðŸ‡³"},
    {"name": "Turkish", "flag": "ðŸ‡¹ðŸ‡·"},
    {"name": "Italian", "flag": "ðŸ‡®ðŸ‡¹"},
    {"name": "Thai", "flag": "ðŸ‡¹ðŸ‡­"},
    {"name": "Swahili", "flag": "ðŸ‡°ðŸ‡ª"},
    {"name": "Dutch", "flag": "ðŸ‡³ðŸ‡±"},
    {"name": "Polish", "flag": "ðŸ‡µðŸ‡±"},
    {"name": "Ukrainian", "flag": "ðŸ‡ºðŸ‡¦"},
    {"name": "Indonesian", "flag": "ðŸ‡®ðŸ‡©"},
    {"name": "Malay", "flag": "ðŸ‡²ðŸ‡¾"},
    {"name": "Filipino", "flag": "ðŸ‡µðŸ‡­"},
    {"name": "Persian", "flag": "ðŸ‡®ðŸ‡·"},
    {"name": "Amharic", "flag": "ðŸ‡ªðŸ‡¹"},
    {"name": "Somali", "flag": "ðŸ‡¸ðŸ‡´"},
    {"name": "Swedish", "flag": "ðŸ‡¸ðŸ‡ª"},
    {"name": "Norwegian", "flag": "ðŸ‡³ðŸ‡´"},
    {"name": "Danish", "flag": "ðŸ‡©ðŸ‡°"},
    {"name": "Finnish", "flag": "ðŸ‡«ðŸ‡®"},
    {"name": "Greek", "flag": "ðŸ‡¬ðŸ‡·"},
    {"name": "Hebrew", "flag": "ðŸ‡®ðŸ‡±"},
    {"name": "Czech", "flag": "ðŸ‡¨ðŸ‡¿"},
    {"name": "Hungarian", "flag": "ðŸ‡­ðŸ‡º"},
    {"name": "Romanian", "flag": "ðŸ‡·ðŸ‡´"},
    {"name": "Nepali", "flag": "ðŸ‡³ðŸ‡µ"},
    {"name": "Sinhala", "flag": "ðŸ‡±ðŸ‡°"},
    {"name": "Tamil", "flag": "ðŸ‡®ðŸ‡³"},
    {"name": "Telugu", "flag": "ðŸ‡®ðŸ‡³"},
    {"name": "Kannada", "flag": "ðŸ‡®ðŸ‡³"},
    {"name": "Malayalam", "flag": "ðŸ‡®ðŸ‡³"},
    {"name": "Gujarati", "flag": "ðŸ‡®ðŸ‡³"},
    {"name": "Punjabi", "flag": "ðŸ‡®ðŸ‡³"},
    {"name": "Marathi", "flag": "ðŸ‡®ðŸ‡³"},
    {"name": "Oriya", "flag": "ðŸ‡®ðŸ‡³"},
    {"name": "Assamese", "flag": "ðŸ‡®ðŸ‡³"},
    {"name": "Khmer", "flag": "ðŸ‡°ðŸ‡­"},
    {"name": "Lao", "flag": "ðŸ‡±ðŸ‡¦"},
    {"name": "Burmese", "flag": "ðŸ‡²ðŸ‡²"},
    {"name": "Georgian", "flag": "ðŸ‡¬ðŸ‡ª"},
    {"name": "Armenian", "flag": "ðŸ‡¦ðŸ‡²"},
    {"name": "Azerbaijani", "flag": "ðŸ‡¦ðŸ‡¿"},
    {"name": "Kazakh", "flag": "ðŸ‡°ðŸ‡¿"},
    {"name": "Uzbek", "flag": "ðŸ‡ºðŸ‡¿"},
    {"name": "Kyrgyz", "flag": "ðŸ‡°ðŸ‡¬"},
    {"name": "Tajik", "flag": "ðŸ‡¹ðŸ‡¯"},
    {"name": "Turkmen", "flag": "ðŸ‡¹ðŸ‡²"},
    {"name": "Mongolian", "flag": "ðŸ‡²ðŸ‡³"},
    {"name": "Estonian", "flag": "ðŸ‡ªðŸ‡ª"},
    {"name": "Latvian", "flag": "ðŸ‡±ðŸ‡»"},
    {"name": "Lithuanian", "flag": "ðŸ‡±ðŸ‡¹"},
]

def generate_language_keyboard(callback_prefix, message_id=None):
    markup = InlineKeyboardMarkup(row_width=3)
    buttons = []
    for lang in LANGUAGES:
        cb_data = f"{callback_prefix}|{lang['name']}"
        if message_id is not None:
            cb_data += f"|{message_id}"
        buttons.append(InlineKeyboardButton(f"{lang['name']} {lang['flag']}", callback_data=cb_data))
    markup.add(*buttons)
    return markup

@bot.message_handler(commands=['language'])
def select_language_command(message):
    uid = str(message.from_user.id)
    if not check_subscription(message.from_user.id):
        return send_subscription_message(message.chat.id)

    markup = generate_language_keyboard("set_lang")
    bot.send_message(
        message.chat.id,
        "Please choose your preferred language for translations and summaries:",
        reply_markup=markup
    )

@bot.callback_query_handler(func=lambda c: c.data.startswith("set_lang|"))
def callback_set_language(call):
    uid = str(call.from_user.id)
    _, lang = call.data.split("|", 1)
    user_language_settings[uid] = lang
    save_user_language_settings()
    bot.edit_message_text(
        chat_id=call.message.chat.id,
        message_id=call.message.message_id,
        text=f"âœ… Your preferred language is set to **{lang}**",
        parse_mode="Markdown"
    )
    bot.answer_callback_query(call.id, text=f"Language set to {lang}")

@bot.callback_query_handler(func=lambda c: c.data.startswith("btn_translate|"))
def button_translate_handler(call):
    uid = str(call.from_user.id)
    _, message_id_str = call.data.split("|", 1)
    message_id = int(message_id_str)

    if uid not in user_transcriptions or message_id not in user_transcriptions[uid]:
        bot.answer_callback_query(call.id, "No transcription found for this message.")
        return

    preferred_lang = user_language_settings.get(uid)
    if preferred_lang:
        bot.answer_callback_query(call.id, "Translating...")
        do_translate_with_saved_lang(call.message, uid, preferred_lang, message_id)
    else:
        markup = generate_language_keyboard("translate_to", message_id)
        bot.edit_message_text(
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            text="Select the language you want to translate into:",
            reply_markup=markup
        )
    bot.answer_callback_query(call.id)

@bot.callback_query_handler(func=lambda c: c.data.startswith("btn_summarize|"))
def button_summarize_handler(call):
    uid = str(call.from_user.id)
    _, message_id_str = call.data.split("|", 1)
    message_id = int(message_id_str)

    if uid not in user_transcriptions or message_id not in user_transcriptions[uid]:
        bot.answer_callback_query(call.id, "No transcription found for this message.")
        return

    preferred_lang = user_language_settings.get(uid)
    if preferred_lang:
        bot.answer_callback_query(call.id, "Summarizing...")
        do_summarize_with_saved_lang(call.message, uid, preferred_lang, message_id)
    else:
        markup = generate_language_keyboard("summarize_in", message_id)
        bot.edit_message_text(
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            text="Select the language you want the summary in:",
            reply_markup=markup
        )
    bot.answer_callback_query(call.id)

@bot.callback_query_handler(func=lambda c: c.data.startswith("translate_to|"))
def callback_translate_to(call):
    uid = str(call.from_user.id)
    parts = call.data.split("|")
    lang = parts[1]
    message_id = int(parts[2]) if len(parts) > 2 else None

    user_language_settings[uid] = lang
    save_user_language_settings()
    bot.edit_message_text(
        chat_id=call.message.chat.id,
        message_id=call.message.message_id,
        text=f"Translating to **{lang}**...",
        parse_mode="Markdown"
    )
    if message_id:
        do_translate_with_saved_lang(call.message, uid, lang, message_id)
    else:
        if uid in user_transcriptions and call.message.reply_to_message and call.message.reply_to_message.message_id in user_transcriptions[uid]:
            do_translate_with_saved_lang(call.message, uid, lang, call.message.reply_to_message.message_id)
        else:
            bot.send_message(call.message.chat.id, "No transcription found. Please use the inline buttons on the transcription.")
    bot.answer_callback_query(call.id)

@bot.callback_query_handler(func=lambda c: c.data.startswith("summarize_in|"))
def callback_summarize_in(call):
    uid = str(call.from_user.id)
    parts = call.data.split("|")
    lang = parts[1]
    message_id = int(parts[2]) if len(parts) > 2 else None

    user_language_settings[uid] = lang
    save_user_language_settings()
    bot.edit_message_text(
        chat_id=call.message.chat.id,
        message_id=call.message.message_id,
        text=f"Summarizing in **{lang}**...",
        parse_mode="Markdown"
    )
    if message_id:
        do_summarize_with_saved_lang(call.message, uid, lang, message_id)
    else:
        if uid in user_transcriptions and call.message.reply_to_message and call.message.reply_to_message.message_id in user_transcriptions[uid]:
            do_summarize_with_saved_lang(call.message, uid, lang, call.message.reply_to_message.message_id)
        else:
            bot.send_message(call.message.chat.id, "No transcription found. Please use the inline buttons on the transcription.")
    bot.answer_callback_query(call.id)

def do_translate_with_saved_lang(message, uid, lang, message_id):
    original = user_transcriptions.get(uid, {}).get(message_id, "")
    if not original:
        bot.send_message(message.chat.id, "No transcription available to translate.")
        return

    prompt = f"Translate the following text into {lang}. Provide only the translated text:\n\n{original}"
    bot.send_chat_action(message.chat.id, 'typing')
    translated = ask_gemini(uid, prompt)

    if translated.startswith("Error:"):
        bot.send_message(message.chat.id, f"Translation error: {translated}")
        return

    if len(translated) > 4000:
        fn = 'translation.txt'
        with open(fn, 'w', encoding='utf-8') as f:
            f.write(translated)
        bot.send_chat_action(message.chat.id, 'upload_document')
        with open(fn, 'rb') as doc:
            bot.send_document(message.chat.id, doc, caption=f"Translation to {lang}", reply_to_message_id=message_id)
        os.remove(fn)
    else:
        bot.send_message(message.chat.id, translated, reply_to_message_id=message_id)

def do_summarize_with_saved_lang(message, uid, lang, message_id):
    original = user_transcriptions.get(uid, {}).get(message_id, "")
    if not original:
        bot.send_message(message.chat.id, "No transcription available to summarize.")
        return

    prompt = f"Summarize the following text in {lang}. Provide only the summary:\n\n{original}"
    bot.send_chat_action(message.chat.id, 'typing')
    summary = ask_gemini(uid, prompt)

    if summary.startswith("Error:"):
        bot.send_message(message.chat.id, f"Summarization error: {summary}")
        return

    if len(summary) > 4000:
        fn = 'summary.txt'
        with open(fn, 'w', encoding='utf-8') as f:
            f.write(summary)
        bot.send_chat_action(message.chat.id, 'upload_document')
        with open(fn, 'rb') as doc:
            bot.send_document(message.chat.id, doc, caption=f"Summary in {lang}", reply_to_message_id=message_id)
        os.remove(fn)
    else:
        bot.send_message(message.chat.id, summary, reply_to_message_id=message_id)

@bot.message_handler(commands=['translate'])
def handle_translate(message):
    uid = str(message.from_user.id)
    if not check_subscription(message.from_user.id):
        return send_subscription_message(message.chat.id)

    if not message.reply_to_message or uid not in user_transcriptions or message.reply_to_message.message_id not in user_transcriptions[uid]:
        return bot.send_message(message.chat.id, "Reply to a transcription message to translate it.")

    transcription_message_id = message.reply_to_message.message_id
    preferred_lang = user_language_settings.get(uid)
    if preferred_lang:
        do_translate_with_saved_lang(message, uid, preferred_lang, transcription_message_id)
    else:
        markup = generate_language_keyboard("translate_to", transcription_message_id)
        bot.send_message(
            message.chat.id,
            "Select the language you want to translate into:",
            reply_markup=markup
        )

@bot.message_handler(commands=['summarize'])
def handle_summarize(message):
    uid = str(message.from_user.id)
    if not check_subscription(message.from_user.id):
        return send_subscription_message(message.chat.id)

    if not message.reply_to_message or uid not in user_transcriptions or message.reply_to_message.message_id not in user_transcriptions[uid]:
        return bot.send_message(message.chat.id, "Reply to a transcription message to summarize it.")

    transcription_message_id = message.reply_to_message.message_id
    preferred_lang = user_language_settings.get(uid)
    if preferred_lang:
        do_summarize_with_saved_lang(message, uid, preferred_lang, transcription_message_id)
    else:
        markup = generate_language_keyboard("summarize_in", transcription_message_id)
        bot.send_message(
            message.chat.id,
            "Select the language you want the summary in:",
            reply_markup=markup
        )

def transcribe(path: str) -> str | None:
    try:
        segments, _ = model.transcribe(path, beam_size=1)
        return " ".join(segment.text for segment in segments)
    except Exception as e:
        logging.error(f"Transcription error: {e}")
        return None

@bot.message_handler(func=lambda m: True, content_types=['text', 'photo', 'sticker', 'document'])
def fallback(message):
    update_user_activity(message.from_user.id)
    if not check_subscription(message.from_user.id):
        return send_subscription_message(message.chat.id)
    bot.send_message(message.chat.id, "Please send only voice, audio, video, or a TikTok/YouTube link.")

@app.route('/', methods=['POST'])
def webhook():
    if request.headers.get('content-type') == 'application/json':
        update = telebot.types.Update.de_json(request.get_data().decode('utf-8'))
        bot.process_new_updates([update])
        return '', 200
    return abort(403)

@app.route('/set_webhook', methods=['GET','POST'])
def set_webhook():
    url = "https://only-me-cwkd.onrender.com"
    bot.set_webhook(url=url)
    return f"Webhook set to {url}", 200

@app.route('/delete_webhook', methods=['GET','POST'])
def delete_webhook():
    bot.delete_webhook()
    return 'Webhook deleted.', 200

if __name__ == "__main__":
    if os.path.exists(DOWNLOAD_DIR):
        shutil.rmtree(DOWNLOAD_DIR)
    os.makedirs(DOWNLOAD_DIR, exist_ok=True)
    set_bot_info()
    bot.delete_webhook()
    bot.set_webhook(url="https://telegram-bot-media-transcriber-ihi5.onrender.com")
    app.run(host="0.0.0.0", port=int(os.environ.get('PORT', 8080)))
